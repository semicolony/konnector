#!/usr/bin/env python3


import os, argparse, pyperclip
import shlex, subprocess
import requests, json
import time
import logging


DO_API_TOKEN = False            # '' Add your token
DO_SSH_KEY = False              # '' Add your key
DO_SSH_FINGERPRINT = False      # '' Add your fingerprint


API_TOKEN = DO_API_TOKEN if DO_API_TOKEN else os.environ.get('DO_API_TOKEN')
SSH_KEY = DO_SSH_KEY if DO_SSH_KEY else os.environ.get('DO_SSH_KEY')
FINGERPRINT = DO_SSH_FINGERPRINT if DO_SSH_FINGERPRINT \
    else os.environ.get('DO_SSH_FINGERPRINT')


# dryrun globals
dryrun_droplet_id = '532225757'
dryrun_droplet_ip = '203.0.113.10'
dryrun_token = 'ifn203j2jclmv'


# These were the regions which allowed new droplets at the time the script was
# created. Best to check if they are still available for on-demand droplets!
REGIONS = [
    'nyc1',
    'nyc3',
    'sfo3',
    'ams3',
    'sgp1',
    'lon1',
    'fra1',
    'tor1',
    'blr1'
]


def parse_arguments():
    global region
    global name
    global dryrun
    parser = argparse.ArgumentParser(description = f"Usage for {sys.argv[0]}")
    parser.add_argument('name', help='Name for the new droplet', \
        metavar='DROPLET')
    parser.add_argument('region', help='Target region for deployment', \
        metavar='REGION', choices=REGIONS)
    parser.add_argument('--dryrun','-n', help='dryrun', action='store_true')
    args = parser.parse_args()
    name = args.name
    region = args.region
    dryrun = args.dryrun


def err_exit(code,msg,*args):
    print(f"Error in: {__name__}")
    print(f"{msg}")
    if len(args) != 0:
        if args is dict:
            for k,v in args.items():
                print(f"{k}: {v}")
        else:
            args = ' '.join(args)
            print(f"Exception: {args}")
    exit(code)


def create_droplet(name,region):
    print(f"Creating droplet...\nName -> {name}\nRegion -> {region}")
    url = 'https://api.digitalocean.com/v2/droplets'
    headers = {
        'Authorization': f"Bearer {API_TOKEN}",
        'Content-type': 'application/json'
    }
    data = {
        'name': name,
        'region': region,
        'size': 's-2vcpu-4gb',
        'image': 'kuyio-wireguardianvpna',
        'ssh_keys': [FINGERPRINT]
    }
    if not dryrun:
        r = requests.post(url, headers=headers, json=data)
        response = json.loads(r.content.decode('utf-8'))
        if not r.status_code == 202:
            err_exit(1,f"Creation of {name} failed",f"{response}")
        droplet_id = response['droplet']['id']
        print(f"Waiting for the droplet {droplet_id} to be created...")
        time.sleep(15)
        return str(droplet_id)
    else:
        print(f"URL -> {url}")
        print('Headers ->')
        for k,v in headers.items():
            print(f"\t{k} -> {v}")
        print('Data ->')
        for k,v in data.items():
            print(f"\t{k} -> {v}")
        droplet_id = '532225757'
        print(f"Expecting a droplet ID like -> {droplet_id}")
        return droplet_id


def get_public_ipv4(droplet_id):
    cmd = ['doctl', 'compute', 'droplet', 'get', droplet_id, '--format', \
        'PublicIPv4', '--no-header']
    if not dryrun:
        try:
            output = subprocess.run(cmd, stdout=subprocess.PIPE, text=True, \
                check=True)
        except Exception as err:
            err_exit(1,f"{' '.join(cmd)} failed", f"{err}")
        return output.stdout.strip()
    else:
        print(f"Running \'{' '.join(cmd)}\' to query the public IPv4")
        return '203.0.113.10'


def start_konnect(name,droplet_ip):
    key = f"-i {SSH_KEY}" if SSH_KEY else ''
    if not dryrun:
        print(f"Waiting for {name} -> {droplet_ip} to be reachable...")
        time.sleep(120)
        print('Starting konnect docker container...')
        cmd = shlex.split(f'ssh -q {key} -o StrictHostKeyChecking=no \
        root@{droplet_ip} "cd /opt/konnect; echo starting konnect service; \
        docker-compose up -d"')
        try:
            output = subprocess.run(cmd, stdout=subprocess.PIPE, text=True, \
                check=True)
        except Exception as err:
            err_exit(2,f"{' '.join(cmd)} failed", f"{err}")
        else:
            print(output.stdout)
        time.sleep(10)
        print('Getting your authentication token...')
        time.sleep(10)
        cmd = shlex.split(f'''ssh -q {key} -o StrictHostKeyChecking=no \
        root@{droplet_ip} "cd /opt/konnect; docker-compose logs \
        | grep "token" | awk '{{print $14}}'"''')
        try:
            output = subprocess.run(cmd, stdout=subprocess.PIPE, text=True, \
                check=True)
        except Exception as err:
            err_exit(2,f"{' '.join(cmd)} failed", f"{err}")
        print(f"\nToken to validate http://{droplet_ip} -> {output.stdout}\n")
    else:
        print(f" - Connecting to {droplet_ip} after waiting 2 min for bringup")
        print(f" - Starting the konnect docker container")
        print(f" - Connecting again to grep for the authentication token")
        print(f" - Display token to authenticate -> http://{droplet_ip}")


def main():
    parse_arguments()
    droplet_id = (create_droplet(name,region))
    droplet_ip = (get_public_ipv4(droplet_id))
    start_konnect(name,droplet_ip)


if __name__ == '__main__':
    main()
